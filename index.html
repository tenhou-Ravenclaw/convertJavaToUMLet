<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java to UMLet Text Converter モックアップ</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        h1 {
            color: #0056b3;
            text-align: center;
            margin-bottom: 30px;
        }
        .container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
            align-items: flex-start; /* 上揃え */
        }
        .column {
            flex: 1;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .column h2 {
            margin-top: 0;
            color: #0056b3;
            font-size: 1.2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        textarea {
            width: 100%;
            height: 400px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            box-sizing: border-box; /* パディングとボーダーをwidthに含める */
            resize: vertical; /* 縦方向のみリサイズ可能 */
        }
        .center-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px 0;
            margin-top: 50px; /* テキストエリアの高さに合わせて調整 */
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button::before {
            content: '➡️'; /* 矢印アイコン */
            font-size: 1.2em;
        }
        .arrow-icon {
            font-size: 1.5em;
            margin: 10px 0;
            color: #007bff;
        }
    </style>
</head>
<body>
    <h1>Java to UMLet Text Converter モックアップ</h1>

    <div class="container">
        <div class="column">
            <h2>Javaソースコード</h2>
            <textarea id="javaCodeInput" placeholder="ここにJavaソースコードを貼り付けてください。">
// Java Source Code (入力)
public interface Vehicle {
    void start();
}

public class Car extends AbstractVehicle implements Vehicle {
    private String modelName;
    public int speed = 0;

    public Car(String modelName) {
        this.modelName = modelName;
    }

    // AbstractVehicleのメソッドをオーバーライド
    @Override
    public void start() {
        System.out.println("Car started.");
    }

    public void accelerate(int amount) {
        this.speed += amount;
    }
}
            </textarea>
        </div>

        <div class="center-controls">
            <button id="convertButton">変換</button>
        </div>

        <div class="column">
            <h2>UMLetテキスト出力</h2>
            <textarea id="umletTextOutput" readonly></textarea>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const convertButton = document.getElementById('convertButton');
            const javaCodeInput = document.getElementById('javaCodeInput');
            const umletTextOutput = document.getElementById('umletTextOutput');

            /**
             * Javaソースコード解析用のデータ構造
             */
            class JavaClass {
                constructor(name, type = 'class') {
                    this.name = name;
                    this.type = type; // 'class', 'interface', 'abstract', 'enum'
                    this.packageName = '';
                    this.modifiers = new Set(); // public, private, protected, static, final, abstract
                    this.fields = [];
                    this.methods = [];
                    this.constructors = [];
                    this.superClass = null;
                    this.interfaces = [];
                    this.innerClasses = [];
                }
            }

            class JavaField {
                constructor(name, type, modifiers = []) {
                    this.name = name;
                    this.type = type;
                    this.modifiers = new Set(modifiers);
                    this.defaultValue = null;
                }
            }

            class JavaMethod {
                constructor(name, returnType = 'void', modifiers = []) {
                    this.name = name;
                    this.returnType = returnType;
                    this.modifiers = new Set(modifiers);
                    this.parameters = [];
                    this.isConstructor = false;
                    this.isAbstract = false;
                }
            }

            class JavaParameter {
                constructor(name, type) {
                    this.name = name;
                    this.type = type;
                }
            }

            /**
             * Javaソースコード解析器
             */
            class JavaParser {
                constructor() {
                    this.classes = [];
                    this.imports = [];
                    this.packageName = '';
                }

                /**
                 * Javaソースコードを解析してクラス情報を抽出
                 */
                parse(sourceCode) {
                    this.classes = [];
                    this.imports = [];
                    this.packageName = '';

                    // ソースコードの前処理（コメント削除、正規化）
                    const cleanCode = this.preprocessCode(sourceCode);
                    
                    // パッケージ宣言の解析
                    this.parsePackage(cleanCode);
                    
                    // インポート文の解析
                    this.parseImports(cleanCode);
                    
                    // クラス・インターフェース定義の解析
                    this.parseClasses(cleanCode);
                    
                    return {
                        packageName: this.packageName,
                        imports: this.imports,
                        classes: this.classes
                    };
                }

                /**
                 * ソースコードの前処理
                 */
                preprocessCode(code) {
                    // 単行コメントを削除
                    code = code.replace(/\/\/.*$/gm, '');
                    
                    // 複数行コメントを削除
                    code = code.replace(/\/\*[\s\S]*?\*\//g, '');
                    
                    // 文字列リテラル内の特殊文字をエスケープ（簡易版）
                    code = code.replace(/"([^"\\]|\\.)*"/g, '"STRING_LITERAL"');
                    code = code.replace(/'([^'\\]|\\.)*'/g, "'CHAR_LITERAL'");
                    
                    return code;
                }

                /**
                 * パッケージ宣言の解析
                 */
                parsePackage(code) {
                    const packageMatch = code.match(/package\s+([a-zA-Z_][a-zA-Z0-9_.]*)\s*;/);
                    if (packageMatch) {
                        this.packageName = packageMatch[1];
                    }
                }

                /**
                 * インポート文の解析
                 */
                parseImports(code) {
                    const importPattern = /import\s+(static\s+)?([a-zA-Z_][a-zA-Z0-9_.*]*)\s*;/g;
                    let match;
                    while ((match = importPattern.exec(code)) !== null) {
                        this.imports.push({
                            isStatic: !!match[1],
                            path: match[2]
                        });
                    }
                }

                /**
                 * クラス・インターフェース定義の解析
                 */
                parseClasses(code) {
                    // クラス・インターフェース定義のパターン
                    const classPattern = /(public\s+|private\s+|protected\s+)?(abstract\s+|final\s+|static\s+)?(class|interface|enum)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:extends\s+([a-zA-Z_][a-zA-Z0-9_]*))?\s*(?:implements\s+([a-zA-Z_][a-zA-Z0-9_,\s]*))?\s*\{/g;
                    
                    let match;
                    while ((match = classPattern.exec(code)) !== null) {
                        const javaClass = new JavaClass(match[4], match[3]);
                        
                        // 修飾子の解析
                        if (match[1]) javaClass.modifiers.add(match[1].trim());
                        if (match[2]) javaClass.modifiers.add(match[2].trim());
                        
                        // 継承関係の解析
                        if (match[5]) {
                            javaClass.superClass = match[5];
                        }
                        
                        // 実装インターフェースの解析
                        if (match[6]) {
                            javaClass.interfaces = match[6].split(',').map(i => i.trim());
                        }
                        
                        // クラス本体の解析
                        const classBodyStart = match.index + match[0].length - 1;
                        const classBody = this.extractClassBody(code, classBodyStart);
                        
                        this.parseClassBody(javaClass, classBody);
                        this.classes.push(javaClass);
                    }
                }

                /**
                 * クラス本体の抽出（ネストした括弧に対応）
                 */
                extractClassBody(code, startIndex) {
                    let braceCount = 1;
                    let i = startIndex + 1;
                    
                    while (i < code.length && braceCount > 0) {
                        if (code[i] === '{') {
                            braceCount++;
                        } else if (code[i] === '}') {
                            braceCount--;
                        }
                        i++;
                    }
                    
                    return code.substring(startIndex + 1, i - 1);
                }

                /**
                 * クラス本体の解析（フィールド・メソッド）
                 */
                parseClassBody(javaClass, classBody) {
                    // フィールドの解析
                    this.parseFields(javaClass, classBody);
                    
                    // メソッドの解析
                    this.parseMethods(javaClass, classBody);
                }

                /**
                 * フィールドの解析
                 */
                parseFields(javaClass, classBody) {
                    // フィールド定義のパターン
                    const fieldPattern = /(public|private|protected)?\s*(static|final)?\s*([a-zA-Z_][a-zA-Z0-9_<>\[\]]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:=\s*[^;]+)?\s*;/g;
                    
                    let match;
                    while ((match = fieldPattern.exec(classBody)) !== null) {
                        const modifiers = [];
                        if (match[1]) modifiers.push(match[1]);
                        if (match[2]) modifiers.push(match[2]);
                        
                        const field = new JavaField(match[4], match[3], modifiers);
                        javaClass.fields.push(field);
                    }
                }

                /**
                 * メソッドの解析
                 */
                parseMethods(javaClass, classBody) {
                    // メソッド定義のパターン
                    const methodPattern = /(public|private|protected)?\s*(static|final|abstract)?\s*([a-zA-Z_][a-zA-Z0-9_<>\[\]]*|void)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([^)]*)\)\s*(?:throws\s+[^{;]+)?\s*[{;]/g;
                    
                    let match;
                    while ((match = methodPattern.exec(classBody)) !== null) {
                        const modifiers = [];
                        if (match[1]) modifiers.push(match[1]);
                        if (match[2]) modifiers.push(match[2]);
                        
                        const method = new JavaMethod(match[4], match[3], modifiers);
                        
                        // コンストラクタかどうかの判定
                        method.isConstructor = (match[4] === javaClass.name);
                        if (method.isConstructor) {
                            method.returnType = null;
                        }
                        
                        // abstract メソッドかどうかの判定
                        method.isAbstract = modifiers.includes('abstract');
                        
                        // パラメータの解析
                        if (match[5].trim()) {
                            method.parameters = this.parseParameters(match[5]);
                        }
                        
                        if (method.isConstructor) {
                            javaClass.constructors.push(method);
                        } else {
                            javaClass.methods.push(method);
                        }
                    }
                }

                /**
                 * メソッドパラメータの解析
                 */
                parseParameters(parametersString) {
                    const parameters = [];
                    const paramParts = parametersString.split(',');
                    
                    for (const part of paramParts) {
                        const trimmed = part.trim();
                        if (trimmed) {
                            const paramMatch = trimmed.match(/([a-zA-Z_][a-zA-Z0-9_<>\[\]]*)\s+([a-zA-Z_][a-zA-Z0-9_]*)/);
                            if (paramMatch) {
                                parameters.push(new JavaParameter(paramMatch[2], paramMatch[1]));
                            }
                        }
                    }
                    
                    return parameters;
                }
            }

            convertButton.addEventListener('click', () => {
                try {
                    const javaCode = javaCodeInput.value;
                    const parser = new JavaParser();
                    const parseResult = parser.parse(javaCode);
                    
                    // パース結果をUMLetテキストに変換
                    const umletText = generateUMLetText(parseResult);
                    umletTextOutput.value = umletText;
                } catch (error) {
                    umletTextOutput.value = `エラーが発生しました: ${error.message}\n\n詳細:\n${error.stack}`;
                }
            });

            /**
             * パース結果からUMLetテキストを生成
             */
            function generateUMLetText(parseResult) {
                let output = '';
                
                // ヘッダーコメント
                output += '// UMLet Text Output (UMLetにコピペする内容)\n';
                if (parseResult.packageName) {
                    output += `// Package: ${parseResult.packageName}\n`;
                }
                output += '// --- クラス定義 ---\n\n';
                
                // 各クラス・インターフェースの出力
                for (const javaClass of parseResult.classes) {
                    output += generateClassText(javaClass) + '\n\n';
                }
                
                // 関係線の生成
                if (parseResult.classes.length > 1) {
                    output += '// --- 関係線（継承・実装）定義 ---\n\n';
                    output += generateRelationships(parseResult.classes);
                }
                
                return output;
            }

            /**
             * 個別クラスのUMLetテキスト生成
             */
            function generateClassText(javaClass) {
                let output = '';
                
                // クラス/インターフェースの種類表示
                if (javaClass.type === 'interface') {
                    output += '<<interface>>\n';
                } else if (javaClass.modifiers.has('abstract')) {
                    output += '<<abstract>>\n';
                } else if (javaClass.type === 'enum') {
                    output += '<<enumeration>>\n';
                }
                
                // クラス名
                output += `${javaClass.name}\n`;
                output += '--\n';
                
                // フィールド
                for (const field of javaClass.fields) {
                    const visibility = getVisibilitySymbol(field.modifiers);
                    const staticModifier = field.modifiers.has('static') ? '{static}' : '';
                    output += `${visibility} ${field.name} : ${field.type} ${staticModifier}\n`.trim() + '\n';
                }
                
                output += '--\n';
                
                // コンストラクタ
                for (const constructor of javaClass.constructors) {
                    const visibility = getVisibilitySymbol(constructor.modifiers);
                    const params = constructor.parameters.map(p => `${p.name}:${p.type}`).join(', ');
                    output += `${visibility} ${constructor.name}(${params})\n`;
                }
                
                // メソッド
                for (const method of javaClass.methods) {
                    const visibility = getVisibilitySymbol(method.modifiers);
                    const staticModifier = method.modifiers.has('static') ? '{static}' : '';
                    const abstractModifier = method.isAbstract ? '{abstract}' : '';
                    const params = method.parameters.map(p => `${p.name}:${p.type}`).join(', ');
                    const modifiers = [staticModifier, abstractModifier].filter(m => m).join(' ');
                    output += `${visibility} ${method.name}(${params}) : ${method.returnType} ${modifiers}\n`.trim() + '\n';
                }
                
                return output;
            }

            /**
             * 可視性記号の取得
             */
            function getVisibilitySymbol(modifiers) {
                if (modifiers.has('private')) return '-';
                if (modifiers.has('protected')) return '#';
                if (modifiers.has('public')) return '+';
                return '+'; // デフォルトはpublic
            }

            /**
             * クラス間の関係線生成
             */
            function generateRelationships(classes) {
                let output = '';
                
                for (const javaClass of classes) {
                    // 継承関係
                    if (javaClass.superClass) {
                        output += `// ${javaClass.name} extends ${javaClass.superClass}\n`;
                        output += `type=lt=<|-\n`;
                        output += `${javaClass.superClass}\n`;
                        output += `${javaClass.name}\n\n`;
                    }
                    
                    // 実装関係
                    for (const interfaceName of javaClass.interfaces) {
                        output += `// ${javaClass.name} implements ${interfaceName}\n`;
                        output += `type=lt=<<|..\n`;
                        output += `${interfaceName}\n`;
                        output += `${javaClass.name}\n\n`;
                    }
                }
                
                return output;
            }
        });
    </script>
</body>
</html>